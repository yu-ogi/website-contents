"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationPluginManager = void 0;
var trigger_1 = require("@akashic/trigger");
/**
 * 操作プラグインからの通知をハンドルするクラス。
 * 本クラスのインスタンスをゲーム開発者が直接生成することはなく、ゲーム開発者が利用する必要もない。
 * @ignore
 */
var OperationHandler = /** @class */ (function () {
    function OperationHandler(code, owner, handler) {
        this._code = code;
        this._handler = handler;
        this._handlerOwner = owner;
    }
    OperationHandler.prototype.onOperation = function (op) {
        var iop;
        if (op instanceof Array) {
            iop = { _code: this._code, data: op };
        }
        else {
            iop = op;
            iop._code = this._code;
        }
        this._handler.call(this._handlerOwner, iop);
    };
    return OperationHandler;
}());
/**
 * 操作プラグインを管理するクラス。
 * 通常は game.json の `operationPlugins` フィールドを基に自動的に初期化される他、
 * ゲーム開発者は本クラスを用いて直接操作プラグインを登録することもできる。
 * 詳細は `this.register()` のコメントを参照。
 *
 * 本クラスのインスタンスをゲーム開発者が直接生成することない。
 */
var OperationPluginManager = /** @class */ (function () {
    function OperationPluginManager(game, viewInfo) {
        this.onOperate = new trigger_1.Trigger();
        this.operated = this.onOperate;
        this.plugins = {};
        this._game = game;
        this._viewInfo = viewInfo;
    }
    /**
     * 操作プラグインを手動で登録する。
     * このメソッドを利用する場合、game.json の `operationPlugins` フィールドから該当の定義を省略する必要がある。
     * 登録後、ゲーム開発者自身で `OperationPluginManager#start()` を呼び出さなければならない点に注意。
     * @param pluginClass new 可能な操作プラグインの実態
     * @param code 操作プラグインの識別コード
     * @param option 操作プラグインのコンストラクタに渡すパラメータ
     */
    OperationPluginManager.prototype.register = function (pluginClass, code, option) {
        return this._instantiateOperationPlugin(pluginClass, code, option);
    };
    /**
     * 対象の操作プラグインを開始する。
     * @param code 操作プラグインの識別コード
     */
    OperationPluginManager.prototype.start = function (code) {
        var plugin = this.plugins[code];
        if (!plugin)
            return;
        plugin.start();
    };
    /**
     * 対象の操作プラグインを終了する。
     * @param code 操作プラグインの識別コード
     */
    OperationPluginManager.prototype.stop = function (code) {
        var plugin = this.plugins[code];
        if (!plugin)
            return;
        plugin.stop();
    };
    OperationPluginManager.prototype.destroy = function () {
        this.stopAll();
        this.onOperate.destroy();
        this.onOperate = undefined;
        this.operated = undefined;
        this.plugins = undefined;
        this._game = undefined;
        this._viewInfo = undefined;
    };
    OperationPluginManager.prototype.reset = function () {
        this.stopAll();
        this.onOperate.removeAll();
        this.plugins = {};
    };
    OperationPluginManager.prototype.stopAll = function () {
        for (var code in this.plugins) {
            if (!this.plugins.hasOwnProperty(code))
                continue;
            var plugin = this.plugins[code];
            if (plugin)
                plugin.stop();
        }
    };
    OperationPluginManager.prototype._instantiateOperationPlugin = function (pluginClass, code, option) {
        if (!pluginClass.isSupported()) {
            return;
        }
        if (this.plugins[code]) {
            throw new Error("Plugin#code conflicted for code: ".concat(code));
        }
        var plugin = new pluginClass(this._game, this._viewInfo, option);
        this.plugins[code] = plugin;
        var handler = new OperationHandler(code, this.onOperate, this.onOperate.fire);
        plugin.operationTrigger.add(handler.onOperation, handler);
        return plugin;
    };
    return OperationPluginManager;
}());
exports.OperationPluginManager = OperationPluginManager;
