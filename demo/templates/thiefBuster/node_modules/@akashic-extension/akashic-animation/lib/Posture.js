"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Posture = void 0;
const AnimeParams_1 = require("./AnimeParams");
const AttrId_1 = require("./AttrId");
// 動的ボーン
// Boneが静的で様々なシステムから参照されるのに対し、
// Postureは実行時に定まるボーンの情報を扱う
// 主なものはAnimationの計算結果
//
class Posture {
    constructor() {
        this.attrs = [];
        this.alphaBlendMode = undefined;
        this.m = new g.PlainMatrix();
        this.attrs[AttrId_1.AttrId.cv] = new AnimeParams_1.CellValue();
        this.attachments = [];
        this.effects = [];
        if (Posture._costbl.length === 0) {
            // [0, 90] degree の範囲をテーブル化
            for (let i = 0; i <= 0x4000; i++) {
                const rad = (Math.PI / 2) * (i / 0x4000);
                Posture._costbl.push(Math.cos(rad));
            }
        }
    }
    reset() {
        const attrs = this.attrs;
        attrs[AttrId_1.AttrId.tx] = attrs[AttrId_1.AttrId.ty] = 0;
        attrs[AttrId_1.AttrId.rz] = 0;
        attrs[AttrId_1.AttrId.sx] = attrs[AttrId_1.AttrId.sy] = 1;
        attrs[AttrId_1.AttrId.lsx] = attrs[AttrId_1.AttrId.lsy] = 1;
        attrs[AttrId_1.AttrId.alpha] = 1;
        attrs[AttrId_1.AttrId.lalpha] = undefined;
        attrs[AttrId_1.AttrId.tu] = attrs[AttrId_1.AttrId.tv] = 0;
        attrs[AttrId_1.AttrId.pvtx] = attrs[AttrId_1.AttrId.pvty] = 0;
        attrs[AttrId_1.AttrId.prio] = 0;
        attrs[AttrId_1.AttrId.iflh] = false;
        attrs[AttrId_1.AttrId.iflv] = false;
        attrs[AttrId_1.AttrId.visibility] = true;
        attrs[AttrId_1.AttrId.cv] = undefined;
        attrs[AttrId_1.AttrId.ccr] = 0;
        attrs[AttrId_1.AttrId.flipH] = false;
        attrs[AttrId_1.AttrId.flipV] = false;
        this.m.reset();
        this.alphaBlendMode = undefined;
        // アニメーション以外の処理で与えられた値はクリアしない
    }
    quickcos(rz_in) {
        let rz = (rz_in * 65536 / 360) | 0; // JSにrzが整数であると伝える。僅かに性能が良くなる気がする、程度だが
        if (rz >= 0) {
            rz = rz & 0xFFFF;
        }
        else {
            rz = 0x10000 - (-rz & 0xFFFF);
        }
        if (rz < 0x4000) {
            return Posture._costbl[rz];
        }
        else if (rz < 0x8000) {
            return -Posture._costbl[0x4000 - (rz - 0x4000)];
        }
        else if (rz < 0xC000) {
            return -Posture._costbl[rz - 0x8000];
        }
        else {
            return Posture._costbl[0x4000 - (rz - 0xC000)];
        }
    }
    updateMatrix() {
        const attrs = this.attrs;
        const _cos = this.quickcos(attrs[AttrId_1.AttrId.rz]);
        const _sin = this.quickcos(attrs[AttrId_1.AttrId.rz] - 90);
        const m = this.m._matrix;
        m[0] = _cos * attrs[AttrId_1.AttrId.sx];
        m[1] = _sin * attrs[AttrId_1.AttrId.sx];
        m[2] = -_sin * attrs[AttrId_1.AttrId.sy];
        m[3] = _cos * attrs[AttrId_1.AttrId.sy];
        m[4] = attrs[AttrId_1.AttrId.tx];
        m[5] = attrs[AttrId_1.AttrId.ty];
    }
}
exports.Posture = Posture;
Posture._costbl = [];
