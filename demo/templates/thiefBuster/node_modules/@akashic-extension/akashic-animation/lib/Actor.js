"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actor = void 0;
const Attachment_1 = require("./Attachment");
const AttrId_1 = require("./AttrId");
const BoneCellCollider_1 = require("./BoneCellCollider");
const BoxVolume_1 = require("./BoxVolume");
const CellAttachment_1 = require("./CellAttachment");
const CircleCollider_1 = require("./CircleCollider");
const CircleVolume_1 = require("./CircleVolume");
const FinalizedCell_1 = require("./FinalizedCell");
const Skeleton_1 = require("./Skeleton");
const vfx = require("./vfx");
// `x`, `y` は左上端を基準に、拡大・縮小・回転の基点は中央を基準とするため、anchorX, anchorY に null 指定。
const flipHMatrix = new g.PlainMatrix(0, 0, -1, 1, 0, null, null);
const flipVMatrix = new g.PlainMatrix(0, 0, 1, -1, 0, null, null);
/*
 * アニメーションフレームカウンタを適切な範囲に調整する。
 *
 * loop===falseの時:
 * cntrが０より小さければ0を、frameCount-1以上であればframeCount-1を返す。
 *
 * loop===trueの時:
 * cntrが時計の針のように[0,frameCount]で一周し循環するように調整されたものを返す。
 *
 * @param cntr アニメーションフレームカウンタ
 * @param frameCount アニメーションのフレーム数
 * @param loop ループ再生するアニメーションならtrueを与える
 */
function adjustCounter(cntr, frameCount, loop) {
    if (loop) {
        while (cntr >= frameCount) {
            cntr -= frameCount;
        }
        while (cntr < 0) {
            cntr += frameCount;
        }
    }
    else {
        if (cntr < 0) {
            cntr = 0;
        }
        else if (cntr > frameCount - 1) {
            cntr = frameCount - 1;
        }
    }
    return cntr;
}
function setupColliderForCell(info, bone) {
    let collider;
    switch (info.boundType) {
        case "aabb":
        case "box":
            // eslint-disable-next-line prefer-const
            collider = new BoneCellCollider_1.BoneCellCollider(bone.name, info.boundType === "aabb");
            break;
        default:
            console.warn("Invalid type combination: " + info.geometryType + ", " + info.boundType);
            break;
    }
    return collider;
}
function setupColliderForCircle(info, bone) {
    let collider;
    switch (info.boundType) {
        case "aabb":
        case "circle":
            // eslint-disable-next-line prefer-const
            collider = new CircleCollider_1.CircleCollider(bone.name, info.boundType === "aabb", info.scaleOption);
            break;
        default:
            console.warn("Invalid type combination: " + info.geometryType + ", " + info.boundType);
            break;
    }
    return collider;
}
// 全てのgeometoryTypeと boundtypeの組み合わせが利用可能 というわけ**ではない**
function setupCollider(bones, actor) {
    bones.forEach((bone) => {
        if (!bone.colliderInfos) {
            return;
        }
        bone.colliderInfos.forEach((info) => {
            let collider;
            switch (info.geometryType) {
                case "cell":
                    collider = setupColliderForCell(info, bone);
                    break;
                case "circle":
                    collider = setupColliderForCircle(info, bone);
                    break;
                case "box":
                    console.warn("Not implemented geometory type " + info.geometryType);
                    break;
                default:
                    console.warn("Unknown geometory type " + info.geometryType);
                    break;
            }
            if (collider) {
                actor.addCollider(collider);
            }
        });
    });
}
/**
 * ボーンベースのアニメーションを描画するエンティティ。
 */
class Actor extends g.E {
    /**
     * 各種パラメータを指定して `Actor` のインスタンスを生成する。
     */
    constructor(param) {
        super(param);
        // resource
        this.resource = param.resource;
        // skeleton
        const boneSet = this.resource.getBoneSetByName(param.boneSetName);
        this.skeleton = new Skeleton_1.Skeleton(boneSet.bones, () => {
            return this.getMatrix();
        });
        // collider
        this.colliders = [];
        setupCollider(boneSet.bones, this);
        // skin
        this.skins = {};
        for (let i = 0; i < param.skinNames.length; i = (i + 1) | 0) {
            const name = param.skinNames[i];
            this.skins[name] = this.resource.getSkinByName(name);
        }
        // animation
        this.animation = this.resource.getAnimationByName(param.animationName);
        // effect
        for (let i = 0, len = this.skeleton.bones.length; i < len; i++) {
            const bone = this.skeleton.bones[i];
            if (!bone.effectName)
                continue;
            const param = this.resource.getEffectParameterByName(bone.effectName);
            if (!param)
                continue;
            const effect = vfx.createEffect(param);
            this.skeleton.getPostureByName(bone.name).effects.push(effect);
            // DEBUG
            effect._name = bone.name;
        }
        // debug
        // this.skeleton._startEffect();
        // TODO: アニメーションリソースから大きさを導き出す方法を考える
        this.width = param.width;
        this.height = param.height;
        // and others
        this._cntr = 0;
        this._nextCntr = 0;
        this._elapse = 0;
        this._inv = new g.PlainMatrix();
        this.pause = false;
        this.loop = true;
        this.playSpeed = param.playSpeed !== undefined && param.playSpeed !== null ? param.playSpeed : 1.0;
        this.nullVisible = false;
        this.boneCoordsVisible = false;
        this.colliderVisible = false;
    }
    /**
     * コライダーを追加する。
     *
     * @param 追加されるコライダー
     */
    addCollider(collider) {
        // TODO: アタッチの成否を扱うべきか検討
        collider.onAttached(this);
        this.colliders.push(collider);
    }
    /**
     * コライダーを削除する。
     *
     * @param collider 削除されるコライダー
     */
    removeCollider(collider) {
        const index = this.colliders.indexOf(collider);
        if (index !== -1) {
            this.colliders.splice(index, 1);
        }
    }
    /**
     * スキンを追加する。
     *
     * 同じ名前を持つスキンがすでにActor内にあるとき、上書きされる。
     *
     * @param skins Actorに追加されるスキンの配列
     */
    setSkins(skins) {
        for (let i = 0; i < skins.length; i = (i + 1) | 0) {
            const skin = skins[i];
            this.skins[skin.name] = skin;
        }
    }
    /**
     * アニメーションの計算を行う。
     *
     * フレームカウンタがインクリメントされ、アニメーションカーブに基づいた各種プロパティの計算を行います。
     */
    calc() {
        if (this.pause) {
            return;
        }
        const anime = this.animation;
        if (anime === undefined) {
            return;
        }
        if (this._elapse !== 0) {
            this.skeleton._handleUserEvent(this._cntr, this._elapse, anime);
        }
        // Set current frame counter
        this._cntr = this._nextCntr;
        // Update posture with animation
        this.skeleton.update(this._cntr, anime, this._elapse / this.scene.game.fps);
        if (!this.loop && ((this._cntr === this.animation.frameCount - 1 && this.playSpeed >= 0) ||
            (this._cntr === 0 && this.playSpeed <= 0))) {
            this.ended.fire();
            this.pause = true;
        }
        // Update additional information around posture
        for (let i = 0; i < this.skeleton.composedCaches.length; i = (i + 1) | 0) {
            const cc = this.skeleton.composedCaches[i];
            cc.finalizedCell = createFinalizedCell(cc, this.skins);
        }
        // Set dirty flag for colliders
        for (let i = 0; i < this.colliders.length; i = (i + 1) | 0) {
            this.colliders[i].dirty = true;
        }
        this._elapse = (anime.fps / this.scene.game.fps) * this.playSpeed;
        const nextCntr = this._cntr + this._elapse;
        if (this.loop && (nextCntr >= anime.frameCount || nextCntr < 0)) {
            // 再生がループして先頭に戻った時点でエフェクトをリセットにする
            // リセットの詳細は実装を確認すること
            this.skeleton.resetEffect();
        }
        this._nextCntr = adjustCounter(nextCntr, anime.frameCount, this.loop);
    }
    /**
     * アニメーションを再生する。
     *
     * @param animationName アニメーション名
     * @param startFrame 再生開始フレーム
     * @param loopFlag 再生をループするか指定するフラグ。真の時ループ再生
     * @param playSpeed 再生速度。1.0で通常の再生速度
     */
    play(animationName, startFrame, loopFlag, playSpeed) {
        this.pause = false;
        this.animation = this.resource.getAnimationByName(animationName);
        this.loop = loopFlag;
        this.playSpeed = playSpeed;
        this._nextCntr = adjustCounter(startFrame, this.animation.frameCount, this.loop);
        this._cntr = this._nextCntr;
        this._elapse = 0;
    }
    /**
     * 現在のアニメーション再生位置。
     */
    set currentFrame(frame) {
        this._nextCntr = adjustCounter(frame, this.animation.frameCount, this.loop);
        this._cntr = this._nextCntr;
        this._elapse = 0;
    }
    get currentFrame() {
        return this._cntr;
    }
    /**
     * アニメーション再生終了イベント。
     */
    get ended() {
        if (!this._ended) {
            this._ended = new g.Trigger();
        }
        return this._ended;
    }
    /**
     * アニメーション計算ハンドラを扱うg.Triggerを取得する。
     *
     * @param boneName ボーン名
     * @param createIfNotExists? g.Triggerが存在しない時、生成するなら true を与える。省略した時 undefined
     */
    calculated(boneName, createIfNotExists) {
        return this.skeleton._getTrigger(boneName, createIfNotExists);
    }
    /**
     * アタッチメントを追加する。
     *
     * 返り値は追加されたアタッチメントである。
     * 第一引数に文字列を指定した時、同名のセルをスキン中から探索、それをboneNameで指定したボーンにアタッチする。
     *
     * @param attachable アタッチメントインスタンスまたは装着済みのスキン中のセルを指定する文字列(セル名)
     * @param boneName アタッチ先のボーン名
     * @param matrix? アタッチ位置を調節するマトリクス
     */
    attach(attachable, boneName, matrix) {
        let attachment = undefined;
        if (typeof attachable === "string") {
            const cellName = attachable;
            Object.keys(this.skins).some((key) => {
                const skin = this.skins[key];
                const cell = skin.cells[cellName];
                if (cell) {
                    attachment = new CellAttachment_1.CellAttachment(cellName, skin, matrix);
                }
                return !!cell; // trueを返すとsome()を終了する
            });
        }
        else if (attachable instanceof Attachment_1.Attachment) {
            attachment = attachable;
        }
        if (attachment) {
            this.skeleton.attach(attachment, boneName);
        }
        return attachment;
    }
    /**
     * アタッチメントを削除する。
     *
     * @param attachment 削除するアタッチメント。
     */
    removeAttachment(attachment) {
        this.skeleton.removeAttachment(attachment);
    }
    /**
     * ボーンの行列を取得する。
     *
     * @param boneName ボーン名。
     */
    getBoneMatrix(boneName) {
        const bones = this.skeleton.bones;
        for (let i = 0, len = bones.length; i < len; i++) {
            if (bones[i].name === boneName) {
                return this.skeleton.composedCaches[bones[i].arrayIndex].m;
            }
        }
        return undefined;
    }
    renderSelf(renderer, camera) {
        // E#render()から呼ばれる
        // すでに E#x, E#y で translate されている
        // # compoedCachesのソートをやめる
        //
        // ソートは最後の最後なのでなんの影響も残さないと考えていたが間違いだった
        // 例えばクリックイベントでActorの機能を使用し、それがcompsosedCachesにアクセスするとする
        // それはゲームループ(大抵はScene#update())以外のタイミングで実行される
        // そのため期待した並び(ソート済み)では *ない* データへのアクセスとなる
        //
        // ソートされた後もcomposedCachesは再利用され、その時の並びでBone#arrayIndexに応じたボーン情報を持つ
        // つまりActor#calc()の時点でcomposedCachesの各Postureは担当するボーンが変化している
        //
        // そのことでわかりにくいバグが生まれた。BoneCellColliderの参照するセルが変化した
        //
        // 単純のためここで配列を複製し、それをソートする
        const sortedComposedCaches = [].concat(this.skeleton.composedCaches);
        sortedComposedCaches.sort((a, b) => {
            if (a.attrs[AttrId_1.AttrId.prio] === b.attrs[AttrId_1.AttrId.prio]) {
                // Array.prototype.sort()は不安定。安定にするために一手間加える
                // DCCツールで優先順位の指定がないとき（全て等しい時）
                // postureの配列の順に描画することを保証したい
                // そのため、prioが等しい時は配列の添字で比較する
                return a.index - b.index;
            }
            else {
                return a.attrs[AttrId_1.AttrId.prio] - b.attrs[AttrId_1.AttrId.prio];
            }
        });
        renderer.save();
        {
            // E#render()が乗算したActor#getMatrix()をキャンセルする。Postureはこのマトリクスを含んでいる
            this._inv.updateByInverse(this.width, this.height, this.scaleX, this.scaleY, this.angle, this.x, this.y, this.anchorX, this.anchorY);
            renderer.transform(this._inv._matrix);
            // render myself
            this.renderPostures(sortedComposedCaches, renderer, camera);
            // render bone local coordinates
            if (this.boneCoordsVisible) {
                this.renderAxes(renderer);
            }
            // render colliders
            if (this.colliderVisible) {
                this.renderColliders(renderer);
            }
        }
        renderer.restore();
        return true;
    }
    renderAxes(renderer) {
        this.skeleton.composedCaches.forEach((cc) => {
            renderer.save();
            {
                renderer.transform(cc.m._matrix);
                renderer.fillRect(0, 0, 16, 1, "#ff0000");
                renderer.fillRect(0, 0, 1, 16, "#00ff00");
            }
            renderer.restore();
        });
    }
    renderColliders(renderer) {
        renderer.save();
        {
            renderer.opacity(0.25);
            this.colliders.forEach((c) => {
                const v = c.getVolume();
                if (!v)
                    return;
                // Draw AABB
                const aabb = v.aabb();
                renderer.fillRect(aabb.origin.x - aabb.extent.width, aabb.origin.y - aabb.extent.height, // position
                aabb.extent.width * 2, aabb.extent.height * 2, // width, height
                "#ff0000");
                // Draw Box
                if (v instanceof BoxVolume_1.BoxVolume) {
                    const box = v;
                    renderer.save();
                    {
                        renderer.transform(box.matrix._matrix);
                        renderer.fillRect(box.origin.x, box.origin.y, box.size.width, box.size.height, // width, height
                        "#00ff00");
                    }
                    renderer.restore();
                }
                else if (v instanceof CircleVolume_1.CircleVolume) {
                    const circle = v;
                    renderer.save();
                    {
                        const div = 128;
                        for (let i = 0; i < div; i++) {
                            renderer.fillRect(circle.pos.x + Math.cos(2 * Math.PI / div * i) * circle.r, circle.pos.y + Math.sin(2 * Math.PI / div * i) * circle.r, 4, 4, "#0000ff");
                        }
                    }
                    renderer.restore();
                }
            });
        }
        renderer.restore();
    }
    renderEffect(effect, renderer, _camera) {
        effect.particleSystem.traverse((e) => {
            const skin = this.resource.getSkinByName(e.userData.skinName);
            const surface = skin.surface;
            const cell = skin.cells[e.userData.cellName];
            const left = cell.pos.x;
            const top = cell.pos.y;
            const width = cell.size.width;
            const height = cell.size.height;
            const particles = e.particles;
            renderer.setCompositeOperation(getCompositeOperation(e.userData.alphaBlendMode));
            for (let i = 0, len = particles.length; i < len; i += 1) {
                const p = particles[i];
                const sx = p.sx * p.sxy;
                const sy = p.sy * p.sxy;
                const cos = Math.cos(p.rz);
                const sin = Math.sin(p.rz);
                const a = cos * sx;
                const b = sin * sx;
                const c = sin * sy;
                const d = cos * sy;
                const px = width * (0.5 + cell.pivot.x);
                const py = height * (0.5 + cell.pivot.y);
                renderer.save();
                renderer.opacity(p.alpha);
                renderer.transform([a, b, -c, d, p.tx, p.ty]);
                renderer.transform([1, 0, 0, 1, -px, -py]);
                renderer.drawImage(surface, left, top, width, height, 0, 0);
                renderer.restore();
            }
        });
    }
    renderPostures(sortedComposedCaches, renderer, camera) {
        const length = sortedComposedCaches.length;
        for (let i = 0; i < length; i = (i + 1) | 0) {
            const cc = sortedComposedCaches[i];
            if (!cc.attrs[AttrId_1.AttrId.visibility]) {
                continue;
            }
            renderer.save();
            {
                renderer.opacity(this.opacity * cc.attrs[AttrId_1.AttrId.alpha]);
                renderer.transform(cc.m._matrix); // ボーンのマトリクスを乗算
                renderer.save();
                {
                    for (let j = 0; j < cc.effects.length; j++) {
                        this.renderEffect(cc.effects[j], renderer, camera);
                    }
                    if (cc.finalizedCell) {
                        renderer.transform(cc.finalizedCell.matrix._matrix);
                    }
                    this.renderSelfCore(renderer, camera, cc.finalizedCell);
                }
                renderer.restore();
                cc.attachments.forEach((attachment) => {
                    attachment.render(renderer);
                });
            }
            renderer.restore();
        }
    }
    renderSelfCore(renderer, _camera, finalizedCell) {
        // 原点に描画する。CANVAS座標系
        // +----------> x
        // |   /\
        // |  /__\
        // | /    \
        // |
        // v
        if (finalizedCell) {
            // ミックスはデフォルト値なので、αブレンドがミックスの場合はcomposite-operation指定処理を省略する
            if (finalizedCell.alphaBlendMode !== undefined && finalizedCell.alphaBlendMode !== "normal") {
                renderer.setCompositeOperation(getCompositeOperation(finalizedCell.alphaBlendMode));
            }
            renderer.drawImage(finalizedCell.surface, finalizedCell.cell.pos.x + (finalizedCell.u * finalizedCell.surface.width), finalizedCell.cell.pos.y + (finalizedCell.v * finalizedCell.surface.height), finalizedCell.cell.size.width, finalizedCell.cell.size.height, 0, 0 // 転送先座標
            );
        }
        else if (this.nullVisible) {
            renderer.fillRect(0, 0, 16, 16, "#ff00ff");
        }
    }
}
exports.Actor = Actor;
function createFinalizedCell(posture, skins) {
    if (posture === undefined || posture.attrs[AttrId_1.AttrId.cv] === undefined) {
        return undefined;
    }
    const attrs = posture.attrs;
    const skin = skins[attrs[AttrId_1.AttrId.cv].skinName];
    if (!skin) {
        return undefined;
    }
    const cell = skin.cells[attrs[AttrId_1.AttrId.cv].cellName];
    if (!cell) {
        return undefined;
    }
    // セル中心位置にアニメーションを反映
    const sgnX = attrs[AttrId_1.AttrId.iflh] ? -1 : 1;
    const sgnY = attrs[AttrId_1.AttrId.iflv] ? -1 : 1;
    let pvtx = sgnX * (cell.pivot.x + attrs[AttrId_1.AttrId.pvtx]);
    let pvty = sgnY * (cell.pivot.y + attrs[AttrId_1.AttrId.pvty]);
    // 正規化された値からピクセル座標系へ
    pvtx = cell.size.width * pvtx;
    pvty = cell.size.height * pvty;
    // セルのボーンに対する姿勢を表す行列を求める
    let m = new g.PlainMatrix();
    if (cell.rz === 0) {
        // pivot(セル中心)がセンターに来るようにマトリクスを操作
        // m = [pivot平行移動] x [センタリング]
        m._matrix[4] = -pvtx - cell.size.width / 2;
        m._matrix[5] = -pvty - cell.size.height / 2;
    }
    else {
        // NOTE: `Cell#rz`のアニメーションをサポートするならキャッシュを諦めることになる
        if (!cell.m) { // lazy construction.
            // m = [回転] x [センタリング]
            const m = new g.PlainMatrix();
            const th = Math.PI * (cell.rz / 180);
            const c = Math.cos(th);
            const s = Math.sin(th);
            const tx = -(cell.size.width / 2);
            const ty = -(cell.size.height / 2);
            m._matrix[0] = c;
            m._matrix[1] = s;
            m._matrix[2] = -s;
            m._matrix[3] = c;
            m._matrix[4] = c * tx - s * ty;
            m._matrix[5] = s * tx + c * ty;
            cell.m = m;
        }
        // pivot(セル中心)がセンターに来るようにマトリクスを操作
        // m = [pivot平行移動] x [回転] x [センタリング]
        m._matrix[4] = -pvtx;
        m._matrix[5] = -pvty;
        m.multiply(cell.m);
    }
    // セルの水平(垂直)フリップとセル画像の左右(上下)反転の両方が指定されていると二重に反転して元に戻るので、どちらか片方が指定されている時のみ反転させる
    if (attrs[AttrId_1.AttrId.flipH] !== attrs[AttrId_1.AttrId.iflh]) {
        m = flipHMatrix.multiplyNew(m);
    }
    if (attrs[AttrId_1.AttrId.flipV] !== attrs[AttrId_1.AttrId.iflv]) {
        m = flipVMatrix.multiplyNew(m);
    }
    const finalizedCell = new FinalizedCell_1.FinalizedCell();
    finalizedCell.surface = skin.surface;
    finalizedCell.cell = cell;
    finalizedCell.u = attrs[AttrId_1.AttrId.tu];
    finalizedCell.v = attrs[AttrId_1.AttrId.tv];
    finalizedCell.matrix = m;
    finalizedCell.alphaBlendMode = posture.alphaBlendMode;
    return finalizedCell;
}
function getCompositeOperation(alphaBlendMode) {
    switch (alphaBlendMode) {
        case "add":
            return "lighter";
        default:
            return "source-over";
    }
}
