"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParticleSystem = void 0;
const Emitter_1 = require("./Emitter");
function traverse(e, callback) {
    callback(e);
    for (let i = 0; i < e.children.length; i++) {
        traverse(e.children[i], callback);
    }
}
/**
 * パーティクルシステム。
 *
 * 複数の Emitter の位置や時間をまとめて操作します。
 */
class ParticleSystem {
    constructor() {
        this.tx = 0;
        this.ty = 0;
        this.emitters = [];
        this.reset();
    }
    start() {
        this.emitterStatus = Emitter_1.EmitterStatus.Running;
        for (let i = 0; i < this.emitters.length; i++) {
            this.emitters[i].start();
        }
    }
    stop() {
        this.emitterStatus = Emitter_1.EmitterStatus.Stop;
        for (let i = 0; i < this.emitters.length; i++) {
            this.emitters[i].stop();
        }
    }
    pause() {
        this.emitterStatus = Emitter_1.EmitterStatus.Pause;
        for (let i = 0; i < this.emitters.length; i++) {
            this.emitters[i].pause();
        }
    }
    reset() {
        this.emitterTime = 0;
        this.emitterStatus = Emitter_1.EmitterStatus.Stop;
        this.skipTick = true;
        for (let i = 0; i < this.emitters.length; i++) {
            this.emitters[i].reset();
        }
    }
    move(dx, dy) {
        this.tx += dx;
        this.ty += dy;
    }
    moveTo(tx, ty) {
        this.tx = tx;
        this.ty = ty;
    }
    addEmitter(e) {
        this.emitters.push(e);
    }
    traverse(callback) {
        for (let i = 0; i < this.emitters.length; i++) {
            traverse(this.emitters[i], callback);
        }
    }
    update(dt) {
        if (this.emitterStatus === Emitter_1.EmitterStatus.Pause) {
            // nothing to do.
        }
        else if (this.emitterStatus === Emitter_1.EmitterStatus.Running) {
            for (let i = 0; i < this.emitters.length; i++) {
                this.emitters[i].update(dt);
            }
            this.tick(dt);
            for (let i = 0; i < this.emitters.length; i++) {
                this.emitters[i].emitTimerAt(this.emitterTime, dt, this.tx, this.ty);
            }
        }
        else if (this.emitterStatus === Emitter_1.EmitterStatus.Stop) {
            for (let i = 0; i < this.emitters.length; i++) {
                this.emitters[i].update(dt);
            }
        }
    }
    tick(dt) {
        if (this.skipTick) {
            this.skipTick = false;
        }
        else {
            this.emitterTime += dt;
        }
    }
}
exports.ParticleSystem = ParticleSystem;
