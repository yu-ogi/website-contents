"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
const AttrId_1 = require("./AttrId");
function checkVersion(version, fname) {
    const r = version.match(/(\d+)\.\d+.\d+/);
    if (!r || (r[1] !== "2" && r[1] !== "3")) {
        // v2.x.x または v3.x.x であることを確認
        throw g.ExceptionFactory.createAssertionError("Invalid fileformat version: " + fname + ", " + version + "<2.0.0");
    }
    return r[1];
}
function bindTextureFromAsset(skin, assets) {
    const assetName = skin.imageAssetName ? skin.imageAssetName : skin.name;
    const anAsset = assets[assetName];
    skin.surface = anAsset.asSurface();
}
function constructBoneTree(bones) {
    for (let i = 0; i < bones.length; i++) {
        const bone = bones[i];
        // シリアライズの時点で欠落するのでここで追加
        bone.parent = undefined;
        bone.children = [];
    }
    for (let i = 0; i < bones.length; i++) {
        const bone = bones[i];
        if (bone.parentIndex >= 0) {
            bone.parent = bones[bone.parentIndex];
            bone.parent.children.push(bone);
        }
    }
}
function loadResourceFromContents(contents, assets, resolver) {
    const resources = [];
    for (let i = 0; i < contents.length; i++) {
        const content = contents[i];
        if (resolver) {
            resolver(content.data, assets);
        }
        resources.push(content.data);
    }
    return resources;
}
function loadResourceFromTextAsset(fileNames, assets, resolver) {
    const resources = [];
    if (fileNames) {
        fileNames.forEach((fname) => {
            const assetName = fname.split(".")[0]; // アセット名は拡張子を覗いたファイル名
            const data = JSON.parse(assets[assetName].data);
            checkVersion(data.version, fname);
            if (resolver) {
                resolver(data.contents, assets);
            }
            resources.push(data.contents);
        });
    }
    return resources;
}
function assignAttributeID(animation) {
    const ct = animation.curveTies;
    for (const key in ct) {
        if (ct.hasOwnProperty(key)) {
            ct[key].curves.forEach((c) => {
                const attrId = AttrId_1.AttrId[c.attribute];
                c.attrId = attrId;
            });
        }
    }
}
function mergeAssetArray(assetArray) {
    const merged = {};
    for (let i = 0; i < assetArray.length; i++) {
        const assets = assetArray[i];
        for (const key in assets) {
            if (assets.hasOwnProperty(key)) {
                merged[key] = assets[key];
            }
        }
    }
    return merged;
}
/**
 * アニメーションリソースクラス
 */
class Resource {
    constructor() {
        this.skins = [];
        this.boneSets = [];
        this.animations = [];
        this.effectParameters = [];
        // ...
    }
    /**
     * asapjテキストアセットを読み込む。関連するアセットがある場合、それも読み込む。
     *
     * すでに読み込んだaapjテキストアセットがあった場合、このResourceインスタンスから削除される。
     *
     * @param assetName asapjテキストアセット名
     * @param assets 利用できるアセット
     * @param ...otherAssets 利用できるアセット（可変長引数）
     */
    loadProject(assetName, assets, ...otherAssets) {
        const mergedAssets = mergeAssetArray([assets].concat(otherAssets));
        const json = mergedAssets[assetName].data;
        const data = JSON.parse(json);
        const majorVersion = checkVersion(data.version, assetName);
        if (majorVersion === "2") {
            this.loadProjectV2(data, assets, ...otherAssets);
            return;
        }
        this.loadProjectV3(data, assets, ...otherAssets);
    }
    /**
     * スキンを取得する。
     *
     * @param name スキン名
     */
    getSkinByName(name) {
        for (let i = 0; i < this.skins.length; i++) {
            if (this.skins[i].name === name) {
                return this.skins[i];
            }
        }
        return undefined;
    }
    /**
     * ボーンセットを取得する。
     *
     * @param name ボーンセット名
     */
    getBoneSetByName(name) {
        let found;
        this.boneSets.some((boneSet) => {
            if (boneSet.name === name) {
                found = boneSet;
                return true;
            }
            else {
                return false;
            }
        });
        return found;
    }
    /**
     * アニメーションを取得する。
     *
     * @param name アニメーション名
     */
    getAnimationByName(name) {
        for (let i = 0; i < this.animations.length; i++) {
            if (this.animations[i].name === name) {
                return this.animations[i];
            }
        }
        return undefined;
    }
    /**
     * エフェクトパラメタを取得する。
     *
     * @param name エフェクパラメタ名
     */
    getEffectParameterByName(name) {
        for (let i = 0, len = this.effectParameters.length; i < len; i++) {
            if (this.effectParameters[i].name === name) {
                return this.effectParameters[i];
            }
        }
        return undefined;
    }
    loadProjectV2(data, assets, ...otherAssets) {
        const mergedAssets = mergeAssetArray([assets].concat(otherAssets));
        this.boneSets = loadResourceFromTextAsset(data.contents.boneSetFileNames, mergedAssets, (c, _asseta) => {
            constructBoneTree(c.bones);
        });
        this.skins = loadResourceFromTextAsset(data.contents.skinFileNames, mergedAssets, bindTextureFromAsset);
        this.animations = loadResourceFromTextAsset(data.contents.animationFileNames, mergedAssets, undefined);
        this.animations.forEach((animation) => {
            assignAttributeID(animation);
        });
        this.effectParameters = loadResourceFromTextAsset(data.contents.effectFileNames, mergedAssets, undefined);
    }
    loadProjectV3(data, assets, ...otherAssets) {
        if (data.type !== "bundle") {
            throw g.ExceptionFactory.createAssertionError("Invalid file type: " + data.type + ", supported only \"bundle\" type");
        }
        const mergedAssets = mergeAssetArray([assets].concat(otherAssets));
        this.boneSets = loadResourceFromContents(data.contents.filter(content => content.type === "bone"), mergedAssets, c => constructBoneTree(c.bones));
        this.skins = loadResourceFromContents(data.contents.filter(content => content.type === "skin"), mergedAssets, bindTextureFromAsset);
        this.animations = loadResourceFromContents(data.contents.filter(content => content.type === "animation"), mergedAssets);
        this.animations.forEach((animation) => {
            assignAttributeID(animation);
        });
        this.effectParameters = loadResourceFromContents(data.contents.filter(content => content.type === "effect"), mergedAssets);
    }
}
exports.Resource = Resource;
