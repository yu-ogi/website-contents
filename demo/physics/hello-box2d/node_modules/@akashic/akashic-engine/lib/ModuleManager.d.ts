import { Asset, ScriptAssetRuntimeValueBase } from "@akashic/pdi-types";
import { AssetManager } from "./AssetManager";
import { Module } from "./Module";
import { RequireCacheable } from "./RequireCacheable";
/**
 * `Module` を管理するクラス。
 * このクラスのインスタンスは `Game` に一つ存在し、スクリプトアセットの require() の解決に利用される。
 * 本クラスのインスタンスをゲーム開発者が直接生成することはなく、ゲーム開発者が利用する必要もない。
 */
export declare class ModuleManager {
    /**
     * アセットの管理者。
     * @private
     */
    _assetManager: AssetManager;
    /**
     * ScriptAssetの実行結果キャッシュ。
     * g.require経由の場合ここに格納される。
     * @private
     */
    _scriptCaches: {
        [key: string]: RequireCacheable;
    };
    /**
     * @private
     */
    _runtimeValueBase: ScriptAssetRuntimeValueBase;
    constructor(runtimeBase: ScriptAssetRuntimeValueBase, assetManager: AssetManager);
    /**
     * node.js の require() ライクな読み込み処理を行い、その結果を返す。
     *
     * node.jsのrequireに限りなく近いモデルでrequireする。
     * ただしアセットIDで該当すればそちらを優先する。また node.js のコアモジュールには対応していない。
     * 通常、ゲーム開発者が利用するのは `Module#require()` であり、このメソッドはその内部実装を提供する。
     *
     * @ignore
     * @param path requireのパス。相対パスと、Asset識別名を利用することが出来る。
     *              なお、./xxx.json のようにjsonを指定する場合、そのAssetはTextAssetである必要がある。
     *              その他の形式である場合、そのAssetはScriptAssetである必要がある。
     * @param currentModule このrequireを実行した Module
     * @returns {any} スクリプト実行結果。通常はScriptAsset#executeの結果。
     *                 例外的に、jsonであればTextAsset#dataをJSON.parseした結果が返る
     */
    _require(path: string, currentModule?: Module): any;
    /**
     * 対象のモジュールからの相対パスを、 game.json のディレクトリをルート (`/`) とする `/` 区切りの絶対パス形式として解決する。
     * `this._require()` と違い `path` にアセットIDが指定されても解決しない点に注意。
     * 通常、ゲーム開発者が利用するのは `require.resolve()` であり、このメソッドはその内部実装を提供する。
     *
     * @ignore
     * @param path resolve する対象のパス。相対パスを利用することができる。
     * @param currentModule この require を実行した Module 。
     * @returns {string} 絶対パス
     */
    _resolvePath(path: string, currentModule?: Module): string;
    /**
     * 与えられたパス文字列がファイルパスであると仮定して、対応するアセットを探す。
     * 見つかった場合そのアセットを、そうでない場合 `undefined` を返す。
     * 通常、ゲーム開発者がファイルパスを扱うことはなく、このメソッドを呼び出す必要はない。
     *
     * @ignore
     * @param resolvedPath パス文字列
     * @param liveAssetPathTable パス文字列のプロパティに対応するアセットを格納したオブジェクト
     */
    _findAssetByPathAsFile(resolvedPath: string, liveAssetPathTable: {
        [key: string]: Asset;
    }): Asset | undefined;
    /**
     * 与えられたパス文字列がディレクトリパスであると仮定して、対応するアセットを探す。
     * 見つかった場合そのアセットを、そうでない場合 `undefined` を返す。
     * 通常、ゲーム開発者がファイルパスを扱うことはなく、このメソッドを呼び出す必要はない。
     * ディレクトリ内に package.json が存在する場合、package.json 自体もアセットとして
     * `liveAssetPathTable` から参照可能でなければならないことに注意。
     *
     * @ignore
     * @param resolvedPath パス文字列
     * @param liveAssetPathTable パス文字列のプロパティに対応するアセットを格納したオブジェクト
     */
    _findAssetByPathAsDirectory(resolvedPath: string, liveAssetPathTable: {
        [key: string]: Asset;
    }): Asset | undefined;
    /**
     * 与えられたパス文字列がファイルパスであると仮定して、対応するアセットの絶対パスを解決する。
     * アセットが存在した場合はそのパスを、そうでない場合 `null` を返す。
     * 通常、ゲーム開発者がファイルパスを扱うことはなく、このメソッドを呼び出す必要はない。
     *
     * @ignore
     * @param resolvedPath パス文字列
     * @param liveAssetPathTable パス文字列のプロパティに対応するアセットを格納したオブジェクト
     */
    _resolveAbsolutePathAsFile(resolvedPath: string, liveAssetPathTable: {
        [key: string]: Asset;
    }): string | null;
    /**
     * 与えられたパス文字列がディレクトリパスであると仮定して、対応するアセットの絶対パスを解決する。
     * アセットが存在した場合はそのパスを、そうでない場合 `null` を返す。
     * 通常、ゲーム開発者がファイルパスを扱うことはなく、このメソッドを呼び出す必要はない。
     * ディレクトリ内に package.json が存在する場合、package.json 自体もアセットとして
     * `liveAssetPathTable` から参照可能でなければならないことに注意。
     *
     * @ignore
     * @param resolvedPath パス文字列
     * @param liveAssetPathTable パス文字列のプロパティに対応するアセットを格納したオブジェクト
     */
    _resolveAbsolutePathAsDirectory(resolvedPath: string, liveAssetPathTable: {
        [key: string]: Asset;
    }): string | null;
}
